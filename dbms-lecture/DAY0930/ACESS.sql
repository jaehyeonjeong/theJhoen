
-- 테이블 갯수 출력
SELECT * FROM dict;
--SCOTT(USER)이 사용하는 테이블
SELECT TABLE_NAME FROM USER_TABLES;

SELECT * FROM ALL_TABLES;	-- TABLE 중에 사용자 SCOTT에게 허락해준것

-- SYS 계정이 사용중인 테이블, 일반 사용자들은 조회 안됨.
SELECT * FROM DBA_TABLES;

SELECT * FROM DBA_USERS;

-- 검색을 빠르게 하기 위한 INDEX(순서, 색인)
-- 자동 INDEX는 PK (PRIMARY KEY)를 설정하면 자동으로 만들어 진다.

-- PK는 NOT NULL 조건에 UNIQUE를 만족해야 한다.
-- TABLE만들 떄 제약사항을 PK 걸 수 있다.
-- 자동으로 생성된 PK를 볼 수 있다.
SELECT * FROM USER_INDEXES; -- SCOTT이 만든 INDEX가 있음.

SELECT * FROM EMP;

-- 이렇게 PK로 걸려져 있으면 중복이 된다는 의미이다.
INSERT INTO EMP (EMPNO)
VALUES (7369);

-- 인덱스를 만들기 위한 방법
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);
-- 아래로 조회하면 CREATE한 INDEX를 볼 수 있음.
-- 주의사항 : INDEX를 설정한다고 무조건 빨라지지 않는다.
-- ROW의 수가 작으면 아무 의미 없다.
-- 인덱스를 너무 많은 컬럼에 걸어 두면 INSERT, UPDATE, DELETE 등에서 비용이 발생한다.
-- 조건 검색이 자주 발생하는 컬럼에 걸어두는게 일반적이다.

-- 인덱스를 삭제하는 방법
DROP INDEX IDX_EMP_SAL;

-- VIEW 가상 테이블이라 불림
-- 특정 테이블 마스킹 또는 조인해서 만든다.

-- 20번 부서의 사람들을 조회;
SELECT * FROM (
	SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP 
	WHERE DEPTNO = 20
);

-- VIEW 는 가상 테이블
SELECT * FROM VW_DEPT20;

-- 뷰 생성 쿼리문
CREATE VIEW VW_DEPT20 AS (
	SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP
	WHERE DEPTNO = 20
);

SELECT * FROM USER_INDEXES; 

-- QUIZ
-- VIEW 이름은 VM_EMP30ALL : 30번 부서의 보든 정보
-- READ ONLY로 적용

CREATE VIEW VM_EMP30ALL AS (
	SELECT * FROM EMP 
	WHERE DEPTNO = 30 
);

-- EMPNO, ENAME, DNAME, LOC을 가진 VIEW
CREATE VIEW VM_EMP_DEPT AS (
	SELECT E.EMPNO, E.ENAME, D.DNAME, D.LOC
	FROM EMP E
	JOIN DEPT D ON E.DEPTNO = D.DEPTNO
);



SELECT * FROM VM_EMP_DEPT;

SELECT * FROM VM_EMP30ALL;

DROP VIEW VM_EMP30ALL;
-- top-n 쿼리 제일 위(top)에서 몇 개(n) 들고 온다 (중요)
-- 옛날 방식 : rownum

-- ROWNUM은 가상 컬럼
SELECT rownum, e.* FROM
	(SELECT * FROM emp e ORDER BY SAL DESC) E
WHERE ROWNUM <= 3;

-- 이 방식은 우리가 원하는 결과를 제대로 조회할 수 없음.
-- ROWNUM을 먼저 구한 다음에 ORDERBY를 하기 때문에 원하는 결과를 출력할 수 없다.
SELECT rownum, e.* FROM EMP E
ORDER BY SAL DESC
WHERE ROWNUM <= 3;

-- 두 번째 방법
SELECT EMPNO, ENAME, SAL FROM 
-- 해당 쿼리문의 뜻은 RN이라는 컬럼을 만들고 해당 컬럼을 
	(SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER (ORDER BY SAL DESC) AS RN FROM EMP) 
WHERE RN BETWEEN 1 AND 3;

-- 아래 방법도 잘 쓰지 않는 방식이다.
SELECT EMPNO, ENAME, SAL,   
	 ROW_NUMBER() OVER (ORDER BY SAL DESC) AS RN FROM emp;
-- 지금까지는 예전 오라클로 이렇게 만들 수 있다.

-- 최근 방식
SELECT EMPNO, ENAME, SAL FROM EMP
ORDER BY SAL DESC
FETCH FIRST 5 ROWS ONLY; -- 12C 이상에서 작동하는 방식이다. 
-- 처음에서 5개 들고오기

SELECT EMPNO, ENAME, SAL FROM EMP
ORDER BY SAL DESC
OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY; -- 12C 이상에서 작동하는 방식이다. 
-- 뒤에서 5개를 시작하고 그 다음 5개 들고온다.


-- SEQUENCE
-- 번호 매기기 게시글 작성
-- 1번, 2번 3, 4...
--- BOARD
--- 1. WRITER, TITLE, CONTENT, RGB_DATE
--- 2. WRITER, TITLE, CONTENT, RGB_DATE
--- 3. WRITER, TITLE, CONTENT, RGB_DATE
-- MYSQL은 자동 증가
-- SEQUENCE를 만들어 써야 한다.

CREATE SEQUENCE SEQ_DEPT
INCREMENT BY 1
START WITH 1
MAXVALUE 99999999999999999999999999999
MINVALUE 0
nocycle
cache 10;


DROP TABLE DEPT_SEQ;
CREATE TABLE DEPT_SEQ AS (
	SELECT * FROM DEPT WHERE 1 = 0
);
SELECT * FROM DEPT_SEQ;

INSERT INTO DEPT_SEQ (DEPTNO, DNAME, LOC) 
VALUES (SEQ_DEPT.nextval, 'DB', 'SEOUL');
-- 처음은 NEXTVALUE

DELETE FROM DEPT_SEQ WHERE DEPTNO = 12;

-- 마지막은 CURRENT VALUE
SELECT SEQ_DEPT.CURRVAL FROM DUAL;

-- PK를 내가 지정하지 않는 경우
-- 자동증가

-- 내가 만든 시퀀스를 보기위한 방법
SELECT * FROM USER_SEQUENCES;
DROP SEQUENCE SEQ_DEPT; 	-- 지우면 INSERT도 조회도 안된다.

-- synonym : 동의어 설정, 복잡한 테이블의 이름을 별칭으로 바꾸기
SELECT * FROM emp;

-- 읽을 때는 시노님이라고 읽는다.
CREATE SYNONYM E FOR EMP;
SELECT * FROM E; -- 테이블 자체의 별칭을 부여할 수 있다. (거의 쓸 일이 없다.)
DROP SYNONYM E;  

-- book quiz
-- 다음 SQL 구문을 작성해보시오.
--1.

CREATE SEQUENCE SEQ_EMP
INCREMENT BY 1
START WITH 1
MAXVALUE 99999999999999999999999999999
MINVALUE 0
nocycle
cache 10;


CREATE TABLE DEPT_SEQ AS (
	SELECT * FROM DEPT WHERE 1 = 0
);

SELECT * FROM EMP;
SELECT * FROM USER_INDEXES; 
COMMIT;
DROP INDEX EMPIDX;
CREATE INDEX IDX_EMPIDX_EMPNO ON EMP(EMPNO);

-- BOOKS QUIZ

-- 1-1.
CREATE TABLE EMPIDX AS ( SELECT * FROM EMP WHERE 1 = 0);
INSERT INTO EMPIDX SELECT * FROM EMP;

-- OR 
CREATE TABLE EMPIDX AS SELECT * FROM EMP;
-- 1-2.
CREATE INDEX IDX_EMPIDX_EMPNO ON EMPIDX(EMPNO);
--- 1-3.
SELECT * FROM USER_INDEXES;

CREATE OR REPLACE VIEW NEW_EMPIDK_OVER15K AS (
	SELECT EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM, 'O', 'X') AS COMM
	FROM EMPIDX
	WHERE SAL >= 1500
);

SELECT * FROM NEW_EMPIDK_OVER15K;


-- 2.
CREATE VIEW EMPIDX_OVER15K AS (
	SELECT * FROM EMPIDX 
	WHERE SAL > 1500 
);

SELECT * FROM EMPIDX_OVER15K;

SELECT EMPNO, ENAME, JOB, DEPTNO, SAL,
(CASE 
	WHEN COMM IS NULL THEN 'X'
	ELSE 'O'
END) AS COMM
FROM EMPIDX_OVER15K

---3.
CREATE SEQUENCE SEQ_DEPT
START WITH 1
INCREMENT BY 1
MAXVALUE 99
MINVALUE 1
nocycle
nocache;

CREATE TABLE DEPTSEQ AS (SELECT * FROM DEPT WHERE 1 = 0);

INSERT INTO deptseq (deptno, dname, loc) VALUES (
	SEQ_DEPT.NEXTVAL, 'DB', 'ILSAN'
);

INSERT INTO deptseq (deptno, dname, loc) VALUES (
	SEQ_DEPT.NEXTVAL, 'WEB', 'BUSAN'
);

INSERT INTO deptseq (deptno, dname, loc) VALUES (
	SEQ_DEPT.NEXTVAL, 'MOBILE', 'SEOUL'
);

SELECT * FROM DEPTSEQ;



-- 제약 조건 
-- JPA를 자동으로 테이블을 만들어 준다.
--- NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK
SELECT * FROM EMP;
SELECT * FROM DEPT; -- JOIN할 때 사용하기 위한 키가 필요하다.


-- NOT NULL을 만드는 첫번쨰 방법
CREATE TABLE TABLE_NOTNULL (
	LOGIN_ID VARCHAR2(100) NOT NULL, -- 나는 NULL을 사용하지 않는다
	LOGIN_PW VARCHAR2(100) NOT NULL,
	TEL VARCHAR2(20)
);

SELECT * FROM TABLE_NOTNULL;

INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PW, TEL)
--VALUES ('DEFINEJAE234', NULL, '010-2464-2739');
VALUES ('DEFINEJAE234', '1234', '010-2464-2739');

INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PW, TEL)
--VALUES ('DEFINEJAE234', NULL, '010-2464-2739');
VALUES ('DEFINEDA234', '5678', '');
-- NOT NULL 제약 조건이 걸리면 INSERT, UPDATE시 NULL을 허용하지 않는다.
UPDATE TABLE_NOTNULL SET LOGIN_ID = NULL;	


SELECT * FROM USER_CONSTRAINTS;

-- 이번에는 이름을 직접 작성하는 방법
DROP TABLE TABLE_NOTNULL;

CREATE TABLE TABLE_NOTNULL (
	LOGIN_ID VARCHAR2(100), -- 나는 NULL을 사용하지 않는다
	LOGIN_PW VARCHAR2(100),
	TEL VARCHAR2(20),
	-- 이름 생성
	CONSTRAINT NOTNULL_LOGIN_ID CHECK (LOGIN_ID IS NOT NULL),
	CONSTRAINT NOTNULL_LOGIN_PW CHECK (LOGIN_PW IS NOT NULL)
);
-- SQL, JPA에서는 이름을 자동으로 만들어줌
CREATE TABLE TABLE_NOTNULL (
	LOGIN_ID VARCHAR2(100) CONSTRAINT NOTNULL_LOGIN_ID_02 NOT NULL, -- 나는 NULL을 사용하지 않는다
	LOGIN_PW VARCHAR2(100) CONSTRAINT NOTNULL_LOGIN_PW_02 NOT NULL,
	TEL VARCHAR2(20)
);

SELECT * FROM TABLE_NOTNULL;

ALTER TABLE TABLE_NOTNULL
MODIFY (TEL NOT NULL);	-- 데이터가 이미 있으면 무결성 위배
-- NOT NULL이 없으니 데이터를 넣을 수 있음.
UPDATE TABLE_NOTNULL SET TEL = '010-2464-2739'
WHERE LOGIN_ID = 'DEFINEDA234';

SELECT * FROM USER_CONSTRAINTS;

ALTER TABLE TABLE_NOTNULL
DROP CONSTRAINT NOTNULL_LOGIN_PW;

ALTER TABLE TABLE_NOTNULL
RENAME CONSTRAINT NOTNULL_LOGIN_ID_02 TO AAA;

CREATE TABLE TABLE_UNIQUE (
	LOGIN_ID VARCHAR2(100) CONSTRAINT TABLE_UNIQUE_LOGIN_ID_UNIQUE UNIQUE,
	LOGIN_PW VARCHAR2(100) CONSTRAINT TABLE_UNIQUE_LOGIN_PW_NOTNULL NOT NULL,
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PW, TEL)
VALUES('JJH0306', '1234', '010-1111-1111');

-- 유니크에는 NULL을 입력할 수 있다.
INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PW, TEL)
VALUES(NULL, '1234', '010-1111-1111');


-- PRIMARY KEY
CREATE TABLE TABLE_PK (
	LOGIN_ID VARCHAR2(100) CONSTRAINT TABLE_PK_LOGIN_ID_PK PRIMARY KEY,
	LOGIN_PW VARCHAR2(100) CONSTRAINT TABLE_PK_LOGIN_PW_NOTNULL NOT NULL,
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PW, TEL)
VALUES('JJH0306', '1234', '010-1111-1111');
-- INDEX도 자동으로 같이 설정 됨.

-- UNIQUE와 NOT NULL을 합친 것이 PRIMARY KEY 이다.


--- FOREIGN KEY
SELECT * FROM USER_CONSTRAINTS; -- USER를 조회 할 때 P는 PRIMARY KEY이다. R은 참조키
-- 즉 값이 참조되어있지 않다면 값이 들어갈 수 없다.

CREATE TABLE DEPT_FK (
	DEPTNO NUMBER(2) CONSTRAINT DEPT_FK_DEPTNO_PK PRIMARY KEY,
	DNAME VARCHAR2(100),
	LOC VARCHAR2(100)
);

CREATE TABLE DEPT_FK02 (
	DEPTNO NUMBER(2) CONSTRAINT DEPT_FK02_DEPTNO_PK PRIMARY KEY,
	DNAME VARCHAR2(100),
	LOC VARCHAR2(100)
);

DROP TABLE EMP_FK02;

CREATE TABLE EMP_FK (
	EMPNO NUMBER(4) CONSTRAINT EMP_FK_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(100),
	JOB VARCHAR2(100),
	DEPTNO NUMBER(2) CONSTRAINT EMP_FK_DEPTN_FK REFERENCES DEPT_FK(DEPTNO) -- DEPT 테이블에 있는 DEPTNO 컬럼을 참조한다.
);

CREATE TABLE EMP_FK02 (
	EMPNO NUMBER(4) CONSTRAINT EMP_FK02_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(100),
	JOB VARCHAR2(100),
	DEPTNO NUMBER(2) 
	CONSTRAINT EMP_FK02_DEPTN_FK REFERENCES DEPT_FK02(DEPTNO) ON DELETE CASCADE -- DEPT 테이블에 있는 DEPTNO 컬럼을 참조한다.
--	CONSTRAINT EMP_FK02_DEPTN_FK REFERENCES DEPT_FK02(DEPTNO) ON DELETE SET NULL
	-- 즉, 부모에서 지워지면 자식도 해당되는 데이터를 지운다. SET NULL은 값을 지우지 않고 NULL로 바꿔준다.
);

DELETE FROM DEPT_FK02 WHERE DEPTNO = 10;

INSERT INTO DEPT_FK02(DEPTNO, DNAME, LOC) VALUES (20, 'DB2', 'SEOUL');
INSERT INTO DEPT_FK02(DEPTNO, DNAME, LOC) VALUES (30, 'DB3', 'SEOUL');
INSERT INTO EMP_FK02(EMPNO, ENAME, JOB, DEPTNO) VALUES (1500, '정재현', '유직', 10);
INSERT INTO EMP_FK02(EMPNO, ENAME, JOB, DEPTNO) VALUES (1600, '정해현', '유직', 30);
COMMIT;

DELETE FROM EMP_FK02 WHERE ENAME = '정다현'; -- EMP_FK에 데이터가 이미 있으므로 삭제가 되지 못함.
SELECT * FROM EMP_FK02;
SELECT * FROM DEPT_FK02;

SELECT * FROM TABLE_PK;

SELECT * FROM TABLE_UNIQUE;



--- CHECK
CREATE TABLE TABLE_CHECK (
	LOGIN_ID VARCHAR2(100) CONSTRAINT TABLE_CHK_LOGIN_ID_PK PRIMARY KEY,
	LOGIN_PW VARCHAR2(100) CONSTRAINT TABLE_CHK_LOGIN_PW_CHK CHECK(LENGTH(LOGIN_PW) > 3),
	TEL VARCHAR2(20)
);

CREATE TABLE TABLE_CHECK_ANOTHER (
	LOGIN_ID VARCHAR2(100) CONSTRAINTS TABLE_CHK_ANOTHER_LOGIN_ID_PK PRIMARY KEY,
	LOGIN_PW VARCHAR2(100) CONSTRAINTS TABLE_CHK_ANOTHER_LOGIN_PW_CHK CHECK(LENGTH(LOGIN_PW) > 3),
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_CHECK (LOGIN_ID, LOGIN_PW, TEL)
VALUES ('JJH0306', '1234', NULL);

-- FRONT(JS로 글자수를 체크) 서버로 전달 안되게끔
-- BACK (JAVA STRING의 글자 수를 체크해서 DB로 전달안되고 다시 FRONT로 넘기기) : 최소 서버에서까지 블럭됨
-- DB (CHECK 제약 사항을 걸어서)DB로 입력이 안되고 다시 서버로 넘기기

SELECT * FROM USER_CONSTRAINTS; -- C가 NULL, CHECK인 경우, U : UNIQUE

--- DEFAULT
CREATE TABLE TABLE_DEFAULT (
	LOGIN_ID VARCHAR2(100) CONSTRAINT TABLE_DEFAULT_LOGIN_ID_PK PRIMARY KEY,
	LOGIN_PW VARCHAR2(100) DEFAULT '1234',	-- 제약사항은 아니기에 CONSTRAINT를 하지 않는다.
	TEL VARCHAR2(20)
);
INSERT INTO TABLE_DEFAULT (LOGIN_ID, LOGIN_PW, TEL)
VALUES ('JJH0306', NULL, NULL);
INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL)	-- 인자의 DEFAULT가 없어도
VALUES ('JJH0308', NULL);	-- 자동으로 LOGIN_PW에 DEFAULT된 속성값을 넣음.
SELECT * FROM TABLE_DEFAULT;


CREATE TABLE DEPT_CONST (
	DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
	DNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
	LOC VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);

CREATE TABLE DEPT_CONST02 (
	DEPTNO NUMBER(2) ,
	DNAME VARCHAR2(14) ,
	LOC VARCHAR2(13) ,
	CONSTRAINT DEPTCONST02_DEPTNO_PK PRIMARY KEY(DEPTNO),
	CONSTRAINT DEPTCONST02_DNAME_UNQ UNIQUE(DNAME),
	CONSTRAINT DEPTCONST02_LOC_NN CHECK (LOC IS NOT NULL)
	-- NOT NULL은 인라인 방식으로만 가능
	-- 만약 테이블 레벨 방식으로 처리한다면 CHECK로 처리해야한다.
);

CREATE TABLE DEPT_CONST03 (
	DEPTNO NUMBER(2) ,
	DNAME VARCHAR2(14) ,
	LOC VARCHAR2(13) CONSTRAINT DEPTCONST03_LOC_NN NOT NULL,
	CONSTRAINT DEPTCONST03_DEPTNO_PK PRIMARY KEY(DEPTNO),
	CONSTRAINT DEPTCONST03_DNAME_UNQ UNIQUE(DNAME)
);

CREATE TABLE EMP_CONST (
	EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
	JOB VARCHAR2(9),
	TEL VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
	HIREDATE DATE,
	SAL NUMBER(7, 2) CONSTRAINT EMPCONST_SAL_CHK CHECK (SAL BETWEEN 1000 AND 9999),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);
-- 테이블 레벨 방식
CREATE TABLE EMP_CONST02 (
	EMPNO NUMBER(4) ,
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	TEL VARCHAR2(20),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMPCONST02_EMPNO_PK PRIMARY KEY (EMPNO),
	CONSTRAINT EMPCONST02_ENAME_NN CHECK (ENAME IS NOT NULL),
	CONSTRAINT EMPCONST02_TEL_UNQ UNIQUE (TEL),
	CONSTRAINT EMPCONST02_SAL_CHK CHECK (SAL BETWEEN 1000 AND 9999),
	CONSTRAINT EMPCONST02_DEPTNO_FK FOREIGN KEY (DEPTNO) REFERENCES DEPT_CONST(DEPTNO)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_CONST02'
ORDER BY CONSTRAINT_TYPE;


SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN('DEPT_CONST', 'EMP_CONST') 
ORDER BY TABLE_NAME, CONSTRAINT_NAME;

-- 권한
-- scott 계정의 emp테이블을 orclstudy 계정에 select 할 수 있는 권한을 준다는 의미
GRANT SELECT ON emp TO orclstudy;


GRANT SELECT,INSERT,DELETE ON emp TO orclstudy;

REVOKE SELECT,INSERT,DELETE ON emp FROM orclstudy;






